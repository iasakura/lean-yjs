# Yjsのコアアルゴリズムの正しさをLean4で証明する

## 1. はじめに

Yjsアルゴリズムのコア部分 (integrate) の正しさをLean4で証明しました。

### なぜ？

YjsのアルゴリズムはYATA論文[^1]によって導入され、同論文にて正しさが証明されたとされています。
実際、Yjsの公式ページにもそのように書かれています (TODO: 引用)。
ですが、実はYjsアルゴリズムとYATAは厳密には違います。
また、YATAの証明は

1. YATAで挿入される要素に対してある全順序が定義されること、および
2. YATAアルゴリズムがその全順序に従って要素を挿入すること

の2つの補題から、YATAが収束することを証明していますが、1は複雑怪奇な定義と式変形によって行われ、
2については証明は一切与えられていません。

そこで私は今年の2月頃からYjsアルゴリズム、特に新規Itemを挿入するintegrateアルゴリズムのコア部分をLean4で形式化・証明するプロジェクトを個人で進めていました。
なんどか難所はあったものの、先日無事に1つのマイルストーンを達成することができたので、本稿で解説したいと思います。

## 2. Yjs の基本概念とアーキテクチャ

Yjsは文字列、リスト、辞書等のデータ型とそれらに対する操作をサポートしたCRDTライブラリです。CRDTは簡単に言えば
異なる場所で同期せずに変更を行っても適切に変更データを同期することで一意に収束することが保証されたデータ構造です。

```
ここにYjsのナイスな実行例が入る。
```

YjsはItemというデータ構造を適切な順序でソートされた双方向連結リストにより状態を管理します。
(リスト以外のデータ構造もこの双方向連結リストとして表現されます。)
以下ではこのItemデータ構造について説明します。

### 2.2 Yjs のデータ構造とintegrateアルゴリズム

Yjsのすべてのデータ構造は以下のItemクラスによって管理されます。いかに実際の定義のうち、今回検証の対象とする部分を引用します。

```
YjsのItem.jsの引用
```

(TODO: LLM)
- Itemはデータそのものに加えて、挿入時における直前のデータと直後のデータ (origin, RightOrigin) をもつ
- clientId と counter の組を IDとしてもつ. clientIdは起動時に定まる乱数
- 削除はdeletedフラグを立てるだけの論理削除。今回は無視するが、おそらく容易に扱えるはず。

挿入は以下のintegrateアルゴリズムによって行われます。

```
integrateアルゴリズムの引用
```

integrateは挿入したいItemと現在の双方向連結リストを受け取り、

1. origin/rightOriginの位置を計算し、
2. originからrightOriginまで、適切な挿入位置を計算 (これは後述の後述するように、Yjsが定義するItem上の全順序 $<$ を使って、newItem < itemをみたす最も大きい要素の直前と定義されます)
3. 挿入

と言う流れで行われます。2の全順序関係についてですが、YATA論文曰くItem間に全順序関係を構築することができ、
YATA (およびYjsは) つねにリストをその順序でソートされるように保つとあります。
しかしこのアルゴリズムの正しさをすぐに確信することは難しいと思います。このアルゴリズムが単純に各要素と新規の要素を比較しているだけでは無いことは見てわかると思います。
これはYjsが定義する比較はorigin/rightOriginを遡る必要があり、高速に評価することが難しいためです。
また、dest/scanningという変数も鬼門です。iでbreakしたときの挿入位置が別の変数destで与えられるというのはソート済み配列への挿入というアルゴリズムとしては特殊な形をしていると思います。

YATA論文での順序関係の定義は以下のようになります。

$$
YATA論文の引用
$$

複雑な形をしていますが、これは以下のことを主張しています。

1. originへのエッジがクロスすることがない。
2. 推移律が成り立つ
3. もしoriginが同じで順序が決まらない場合はactorIdを使って順序を決める。

1によると、もし`x.origin < y.origin` ならば、`y < x`であるか、`x < y.originでx<y`であるということになります。
また、actorIdを比較している部分があるのは3の規則によるものです。

Lean4の形式化ではこの規則は用いず、新しく順序関係を再定義しました。当然従うべき規則のみを用いていて、その規則が推移律と反対称律を満たすことを証明しました。
integrateの検証ではループ不変量を設計し、なぜdestまで戻ることになるのかということにも自分なりに直感的な形で形式的な証明を与えました。

## 3. 形式検証のアプローチと証明戦略

### 3.1 形式検証の基本方針

- なぜ Lean4 を選択したか -> 10年前学生時代にCoqのみを使っていたが、別の定理証明支援系を使いたくなった、LLMの恩恵が受けられるかも？（結果としてCopilotの補完以外使うことはほとんど無かった）
- アルゴリズム -> https://github.com/josephg/reference-crdts
  - 双方向連結リスト形式のアルゴリズムは定理証明支援系での形式化は本質的でない難しさを生む
  - 今回は配列ベースのjosephgによる実装を対象とした
- 証明すべき性質の特定 -> integrateが可換であること。
  - 可換性から収束性が導かれるのはop-based CRDTの性質から成り立つ。
  - 実際に、私が証明した性質が収束性につながるか確認するのは今後やっていきたい
    - 例えばMartin KleppmennたちのチームのIsabelleによるCRDTの形式化につなげるとか、Iris分離論理によるop-based CRDTの実装につなげるとか考えられる。
- 段階的な証明戦略の設計
  - YATA論文にならって
    1. YATA順序の全順序性の証明
    2. integrateアルゴリズムの正当性
    の順番で示した。
- チャレンジ
  - YATA論文の定義はwell formedな再帰的定義になっていない
    - productivityに反するのでLean4で定義できない
    - YATAは踏襲せずにもっと直感的な定義を目指す
  - アルゴリズムのループ不変量の設計
    - なぜ決着がついたときにdestまで戻していいのか？という疑問に答える必要がある
      - TODO: アイデアの概略

## 4. Lean による形式モデル化

### 4.1 データ構造の定義

- `YjsItem`と`YjsPtr`の相互再帰定義
- `ActorId`の型定義

### 4.2 順序関係の形式化

#### ItemSet

- YATAは任意の (conflictingな) 要素についての全順序性を仮定したが、すぐにわかるようにそんなことはない。origin=last, rightOrigin=firstとすればあきらかにこれは循環する。
- これと似ているが、任意の2要素a, bについて、その間に要素を挿入すれば a < bとできる。
  - この問題をYATA論文には言及がない
- このような状況を防ぐには、順序を定義する要素には制限が必要。
- 今回は全順序はあるYjsPtrの部分集合に対して定義されるものとし、その部分集合に制限をつけることで定義した。
  - ItemSet.lean/ItemSetInvariant.lean
  - origin/rightOriginについて閉じていることと、上のような状況を排除するための不変条件

#### 順序関係の定義

### 4.3 配列の不変条件

- `YjsArrInvariant`の定義
- ソート済み配列の性質
- 閉じた集合（`IsClosedItemSet`）の概念

## 5. 主要な定理と証明戦略

### 5.1 順序関係の基本性質

- 推移性の証明（`yjs_lt_trans`）
- 反対称性の証明（`yjs_lt_anti_symm`）
- 全順序性の証明（`yjs_lt_total`）

### 5.2 integrate アルゴリズムの健全性

- `integrate_sound`定理の意味
- ループ不変条件（`loop_invariant`）の設計
- 配列の不変条件が保持されることの証明

### 5.3 可換性の証明

- `integrate_commutative`定理
- 操作の順序に依存しない結果の保証
- 分散環境での一貫性の理論的保証

## 実装との対応関係

## 現在の課題と今後の展望

## 9. 関連研究と比較

- 他の CRDT の形式検証事例
- 分散システムの形式検証手法

## 10. まとめ

- 形式検証の意義の再確認
- プロジェクトの現状と意義
- 協調編集システムの信頼性向上への貢献
- 今後の研究課題
