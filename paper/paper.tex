% LeanYjs paper scaffold for ACM conference submission
\documentclass[sigplan]{acmart}
\settopmatter{printfolios=true} % show page numbers for submission

% Metadata placeholders (update for the target venue)
\acmConference[CONF '24]{Conference Name}{Month 0X--0X, 2024}{City, Country}
\acmBooktitle{CONF '24: Conference Name, Month 0X--0X, 2024, City, Country}
\acmPrice{15.00}
\acmISBN{978-x-xxxx-xxxx-x/24/0X}
\acmDOI{10.1145/xxx.xxxxxx}

% Encoding and math packages
\usepackage{iftex}
\usepackage{fontspec}
\usepackage{luatexja-fontspec}
\setmainfont{Latin Modern Roman}
\setsansfont{Latin Modern Sans}
\setmonofont{Latin Modern Mono}
\setmainjfont{IPAexMincho}
\usepackage{amsmath,amssymb,amsthm,mathtools}
\usepackage{lmodern}
\usepackage{mathpartir} % centered inference rules, mathpar environment

% Lists, tables, and code listings
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{enumitem}

\lstset{
  basicstyle=\ttfamily\small,
  numbers=left,
  numberstyle=\scriptsize,
  numbersep=8pt,
  showstringspaces=false,
  keywordstyle=\color{blue!70!black},
  commentstyle=\color{green!40!black},
  stringstyle=\color{orange!60!black},
  frame=single,
  framerule=0.3pt,
  breaklines=true,
  escapeinside={(@}{@)},
}
% Minimal JavaScript language definition for listings
\lstdefinelanguage{JavaScript}{
  morekeywords={const,let,var,function,return,if,else,for,while,break,continue,import,from,export,await,async},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[b]'
}
% Minimal Lean language definition for listings
\lstdefinelanguage{Lean}{
  morekeywords={theorem,structure,def,where,match,with,if,then,else,do,fun,forall,exists,by,open,import,namespace,lemma},
  sensitive=true,
  morecomment=[l]{--},
  morecomment=[s]{/-}{-/},
  morestring=[b]"
}

% Hyperref + clever references (acmart already loads hyperref)
\usepackage[nameinlink,capitalize]{cleveref}

% Theorem environments
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

% User macros
\newcommand{\Lean}{\textsf{Lean}}
\newcommand{\Yjs}{\textsf{Yjs}}
\newcommand{\content}{\textsf{content}} % Item content accessor
\newcommand{\origin}{\textsf{origin}}   % Item origin accessor
\newcommand{\rightOrigin}{\textsf{rightOrigin}} % Item rightOrigin accessor
\newcommand{\id}{\textsf{id}}           % Item id accessor
\newcommand{\First}{\textsf{First}}                     % Special origin for start
\newcommand{\Last}{\textsf{Last}}                       % Special rightOrigin for end
\newcommand{\todo}[1]{\textbf{\textcolor{red}{TODO: #1}}} % TODO marker
\newcommand{\Item}{\textsf{Item}}                      % Item type
\newcommand{\Update}{\textsf{Update}}                  % Update type
\newcommand{\integrate}{\texttt{integrate}}            % integrate function
% Helper to wrap Japanese text without switching the whole document font

\title[Lean-Yjs]{Formal Verification of Yjs Integration Algorithm in the Lean4 Theorem Prover}

\author{Izumi Asakura}
\affiliation{
  \institution{Indivisual}
  \city{Tokyo}
  \country{Japan}
}
\email{i.asakura58@gmail.com}

\renewcommand{\shortauthors}{Izumi Asakura}

\begin{document}

\begin{abstract}
This is a minimal scaffold for a paper accompanying the Lean-Yjs project. Replace this abstract with your own.
\end{abstract}

\maketitle

\citestyle{acmnumeric}

\section{Introduction}
Google docsに代表されるような共同編集機能を持つアプリケーションは多く存在しますが、ネットワークの分断が起きてもそれぞれのユーザーが異なる状態に収束してしまわないことを保証するのは容易ではありません。Conflict-free replicated data types (CRDT) そのような共同編集のためのデータ構造のクラスです。あるアルゴリズムがCRDTであれば、ネットワーク分断時に一時的に異なる状態に遷移しても変更内容を同期すればいつでも同じ状態に収束することを保証します。

Yjsは最も人気のあるCRDTの実装の1つです。Yjsは論文\cite{YATA16}で提案されたYATAというCRDTアルゴリズムを実装しています。YATAはinsert, deleteといった操作をサポートするリスト型で、複数のinsertが同じ位置に発生しても異なる順序にならないように挿入位置を計算します。論文\cite{YATA16}ではYATAの正しさ、つまり収束性 (依存のない操作をどんな順番で実行しても結果の状態が一意に定まること) を証明したとありますが、その証明は複雑で正しさを確認することは難しいです。実際、論文に掲載されているアルゴリズムはYjsに実装されているものとは微妙に異なりますが、その微妙な差によって論文に掲載されているアルゴリズムは間違っていて、収束しないシナリオが存在することを発見しました。\footnote{著者にそのことを確認したところ、手違いで異なるアルゴリズムが掲載されてしまっていたそうですが、論文の出版から私が指摘するまで他に気づいた人はいなかったそうです\cite{YATAwrong}}このことからもYATAの正しさを確認することが難しいことが分かります。

そのような問題から私はYjsの競合解決アルゴリズムを定理証明支援系であるLean4で形式化し証明しました (https://github.com/iasakura/lean-yjs) 。Lean-yjsは単にYATA論文の証明のLean移植ではなく、かなりの大部分を独自に証明しています。その証明は以下のような流れになります。

\begin{enumerate}
  \item YATAのリストの各要素間に定義されるある順序関係が全順序になることを示す
  \item YATAの挿入アルゴリズムがその全順序関係に従って要素を挿入することを示す
  \item 最後に、可換性からYATAがCRDTとなることを示すことで、収束性が得られる
\end{enumerate}

YATAでは1のみの証明が与えられていますが、その中で用いられる順序関係の定義はLean4では採用できないものでした。そのためLean-yjsでは順序関係の定義から独自に行いました。また、2, 3についてはYATA論文では一切証明がないため、こちらも独自に行いました。上で述べた疑似コードの誤りも2の証明を行う中で発見したものです。3は示した可換性がCRDTが求める可換性に合致することを証明することになります。Lean-yjsではYATAの可換性にはいくつかの前提条件が必要になることを明らかにしました。しかしそれらの前提がCRDTで仮定して事実かは自明ではありません。Lean-yjsでは \cite{OOPSLA17} のネットワークモデルをLean4上で定義し、厳密にYATAがそのモデル上でCRDTであることを証明しました。

\paragraph{Contributions.} 本論文の貢献は以下の通りです。
\begin{itemize}
  \item Yjsの競合解決アルゴリズムをLean4で形式化し、その収束性を証明したこと
  \item YATA論文に掲載されている擬似コードに誤りがあることを発見したこと
  \item YATAの正しさを証明するために必要な前提条件を明らかにしたこと
\end{itemize}

\section{Background}

\subsection{Yjs}

Yjsは文字列、リスト、辞書等のデータ型とそれらに対する操作をサポートしたCRDTライブラリです。CRDTはデータの複製に異なる変更を加えても、更新内容を同期することで一意な結果を保証するデータ構造です。\footnote{We focus on op-based CRDTs in this paper.}

以下はYjsによる2つのデータの複製に対して並行にテキストを編集し、変更を同期して同じ値に収束させる例です。

\begin{lstlisting}[language=JavaScript, caption={Yjsによる並行テキスト編集の例}]
// 実行前、doc.getText('shared) -> "X" とする。

// Alice側
const aliceText = aliceDoc.getText('shared')
aliceText.insert(0, 'A')
aliceText.insert(1, 'B')  // "ABX"

// Alice側の変更をエンコード
const aliceUpdate = Y.encodeStateAsUpdate(aliceDoc)

// Bob側（独立して動作）
const bobText = bobDoc.getText('shared')
bobText.insert(0, 'C')
bobText.insert(2, 'D')     // "CXF"

// Bob側の変更をエンコード
const bobUpdate = Y.encodeStateAsUpdate(bobDoc)

// 相互に変更を適用
Y.applyUpdate(aliceDoc, bobUpdate)  // Alice側に反映
Y.applyUpdate(bobDoc, aliceUpdate)  // Bob側に反映

console.log(aliceText.toString())  // "ABCXF"
console.log(bobText.toString())    // "ABCXF"
\end{lstlisting}

この例ではAlice, Bobの双方がそれぞれのローカルに存在するコピー（レプリカ）に対して文字の挿入を行います。その後、Alice, Bobが行った変更を交換し合うことで同じ値に一致します。重要な点は、操作の適用順序に関わらず (Alice -> Bob, Bob -> Aliceのいずれの順でも)、両者の文字列が同じ値に収束することです。操作の適用順序を入れ替えていいのはその2つの操作が並行に行われたときです。操作Aが操作Bを観測しておらず、逆にBもAを観測していないとき2つの操作は並行であるといいます。

\subsection{Data Structure and Algorithm}

Yjsの競合解決で用いられるデータ構造について説明します。

Yjsのデータ型 (List, Map, Text) はすべてItem型のリストで表現されます。Item型は挿入されるデータの他に競合解決のためのメタデータを含みます。

各Itemは以下の情報を持ちます:

\begin{description}
  \item[ID] 全Item間で一意なIDで、起動時に初期化されるクライアントIDと単調増加するカウンタの組
  \item[origin] 挿入する位置のにあった要素への参照
  \item[rightOrigin] 挿入する位置の直後にいた要素への参照
  \item[content] 実際の挿入内容 (挿入される文字など) \footnote{概念上は文字毎にItemが作られますがそれでは文字毎のメタデータが大きすぎるため、Yjsでは連続するIDを持つ文字列が連続して順に挿入される場合にはまとめて1つのItemにする最適化が実装されています。今回はアルゴリズムのコア部分に集中するために検証ではこの振る舞いは無視しました。}
\end{description}

以下では下のような図を使ってItem間の関係を図示します（正式な用語ではありませんが本稿ではこれをItemグラフといいます）。これは、\content{} に値 \texttt{"A"} を持つ \Item{} が、別の\Item{} \texttt{"R"}を\origin{}, \rightOrigin{}として指していることを意味します。また、文字列の先頭への挿入では\origin{}に入る\Item{} がないため\First{} という特殊な値を使います。同様に末尾では\rightOrigin{}に\Last{} を代入することとします。\footnote{First,Lastは実際の実装ではどちらも単にnullとして表現されますが、今回は証明を楽にするために異なる値としました。}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\linewidth]{images/yjs1-1.drawio.png}
  \caption{An item graph}
  \label{fig:item-graph1}
\end{figure}

例えば、上のYjsの実行例での最終結果のItemグラフは下図のようになります。

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\linewidth]{images/yjs1-2.drawio.png}
  \caption{Example item graph after concurrent inserts}
  \label{fig:item-graph2}
\end{figure}

この\Item{}をレプリカ間で同期することで同じItemグラフを共有することができます。よって、あとはこのグラフを「レプリカ間で一貫した方法で」正しい順序に並び替えることができれば、リストとして共有できることになります。この並び替えを定義するのがItem間の順序 $<_Y$ であり、$<_Y$ でソートされた配列に正しい位置に要素を挿入する処理が次節で説明する処理 \texttt{integrate} になります。

\subsection{Insert and Integrate}

\texttt{array.insert(i, obj)} のような新規にオブジェクトを挿入するメソッドを呼ぶと、まずそのオブジェクトを表す \Item{} が生成されます。生成されたItemのフィールドは以下のデータを持ちます。

\begin{itemize}
  \item \id{}: 現在のクライアントIDとそのクライアントでの単調増加するカウンタの組
  \item \origin{}: \texttt{array}の\texttt{i-1}番目の要素への参照
  \item \rightOrigin{}: \texttt{array}の\texttt{i}番目の要素への参照
  \item \content{} : objへの参照
\end{itemize}

その後、生成した\Item{}を\texttt{array}の内部リストの\texttt{i}番目に挿入します。これでローカルのデータ構造に対する処理は終わりです。

変更をリモートと同期するために、生成された更新を表す \Update{} というデータ構造をシリアライズしてリモートに送ります \footnote{実際の実装では削除されたItemのIDのリストも送信します。削除は基本的には\Item{}の削除フラグを立てるだけで競合解決に関与しないので今回は対象外とします。}。\Update{}は生成されたItemのリストなどを含みます。\Update{}を受け取るとクライアントは \texttt{doc.applyUpdate}という関数を \Update{} に対して呼び出します。\texttt{applyUpdate}は\Update{}に含まれる\Item{}のうち、未適用なものを順にリストに挿入していきます。挿入される位置は対象の\Item{}の\origin{}より先で\rightOrigin{}より前のどこかになります。その位置を決定し挿入するアルゴリズムを \texttt{integrate} といいます。

\integrate{}は\Item{}間の順序関係 $<_Y$ に基づいて位置を決めます。\Item{}は\Item{}の\origin{}と\rightOrigin{}の間に挿入されることから、任意の\Item{} $i$において、$i\mathsf{.origin} <_Y i <_Y i\mathsf{.rightOrigin}$ という条件を満たします。$i.\mathsf{origin}$ から $i.\mathsf{rightOrigin}$ までに要素がある場合、これだけではどこに挿入すべきか任意性がありますが、$<_Y$ は全順序であるため一意に位置を決定します。\integrate{}では全順序関係である$<_Y$を用いることで、同じItemの集合を受け取ったすべてのクライアントが同じ状態に収束することを保証します。

なお、このようにYjsでは前半のItemの生成と後半のデータ構造への挿入が分かれていますが、一般にCRDTにおいて前半のItemの生成のようにAPIを実行する代わりに同期に必要なデータを生成することを `prepare` (もしくは `generate`) フェイズ、後半の`integrate`のように同期データを適用することを `effect` フェイズといいます。

\section{The Integrate Algorithm}

Yjsの挿入アルゴリズム \texttt{integrate} を説明します。まず、\texttt{integrate} が並び替えの基準とする関係 $<_Y$ を示し、その後にアルゴリズム本体を説明します。

今回検証するアルゴリズムはYjs本体ではなく、Seph Gentleによる参照実装\footnote{\url{https://github.com/josephg/reference-crdts}}を採用しました。双方向連結リストではなく配列を用い、操作も挿入と削除に単純化されており、依存型理論上での形式化を容易にするための選択です。

\subsection{Item間の順序}

上述のようにYATAはItem間の順序 $<_Y$ に基づいて挿入位置を決めます。Lean-yjsでは $<_Y$ を以下のように再帰的に定義します。再帰は \origin{} / \rightOrigin{} をたどり、最後には \First{} か \Last{} に到達するため必ず停止します。具体的には、$x < y$ は $x.\mathsf{size} + y.\mathsf{size}$ が再帰のたびに減少するように定義されています。ここで \texttt{size} は \Item{} 木の内部ノードと葉の個数です。

\paragraph{定義.} 以下のいずれかが成り立つとき、かつそのときに限り $x < y$ とする。
\begin{enumerate}
  \item $x.\origin < y$。
  \item $x < y.\origin$。
  \item $x.\origin < y < x.\rightOrigin$ かつ $y.\origin < x < y.\rightOrigin$ で、さらに
  \begin{enumerate}
    \item $y.\origin < x.\origin$、または
    \item $x.\origin = y.\origin$ かつ $x.\textsf{clientId} < y.\textsf{clientId}$。
  \end{enumerate}
\end{enumerate}

1, 2は挿入時に隣り合っていた要素の間に入るという自然な条件です。3-aはoriginが異なる場合にoriginとは逆順に並べる規則で、競合してもどちらか一方が連続するように並ぶため interleaving を防ぎます。3-bはoriginでも決着がつかない場合のclient idによるタイブレークです。

より形式的には\cref{fig:order-rules} の導出規則で定義され、Lean-yjsでは帰納型として実装しました。Origin-First / Origin-Last / Origin-FL は \First{} / \Last{} が任意の要素より小さい (大きい) こと、Lt-LeftOrigin / Lt-RightOrigin は \origin{} / \rightOrigin{} との大小関係を伝搬することを表します。Conf-OriginDiff / Conf-OriginSame が3-a, 3-bに対応します。

% rules.texを読み込み
\begin{figure}[t]
  \centering
  \input{yjslt.tex}
  \caption{Rules defining the order $<_Y$}
  \label{fig:order-rules}
\end{figure}

この定義はYATA論文にはないLean-Yjs独自のものです。後述するように、論文の定義はLean4ではstrict positivityを満たさず採用できませんでした。

\subsection{Integrateアルゴリズム}

上で定義した順序 $<_Y$ に基づいて、\texttt{integrate} は挿入位置を決定します。挿入したい要素より大きい最も左の要素を見つけ、その位置に挿入する方針です。全順序 $<_Y$ が計算可能であることから、左から右に順に比較する次のような素朴な実装を考えられます。

\begin{lstlisting}[language=JavaScript, caption={素朴な挿入アルゴリズム}]
integrateNaive(arr, newItem) {
  // findIdx(arr, item)は配列からitemを探す。Firstなら-1, Lastならarr.lengthを返す。
  leftIdx = findIdx(arr, newItem.origin)
  rightIdx = findIdx(arr, newItem.rightOrigin)
  for (i = leftIdx + 1; i < rightIdx; ++i) {
    if (compareItems(newItem, arr[i])) {
      break
    }
  }
  // newItemをi番目に挿入
  arr.insert(i, newItem)
}
\end{lstlisting}

ここで \texttt{compareItems(x, y)} は $x <_Y y$ なら \texttt{true}、そうでないなら \texttt{false} を返します。確かに正しく動作しますが、$<_Y$ の計算は \origin{}/\rightOrigin{} を再帰的にたどるため高コストです。

そこで実際の \texttt{integrate} は、配列がすでに $<_Y$ でソート済みであることを活用し、$<_Y$ を直接計算せず挿入位置を求めます。

\begin{lstlisting}[language=JavaScript, caption={実際のintegrateアルゴリズム}]
integrate(arr, newItem) {
  leftIdx = findPtrIdx(arr, newItem.origin)
  rightIdx = findPtrIdx(arr, newItem.rightOrigin)

  scanning = false
  destIdx = leftIdx + 1
  for (i = leftIdx + 1; i < rightIdx; ++i) {
    other = arr[i]

    // otherのorigin/rightOriginのindexを取得
    oLeftIdx = findPtrIdx(arr, other.origin)
    oRightIdx = findPtrIdx(arr, other.rightOrigin)

    if (oLeftIdx < leftIdx) {
      break // break case: newItem < other が確定
    } else if (oLeftIdx == leftIdx) {
      if (newItem.id > other.id) {
        scanning = false // leave scanning case: newItem > other が確定
      } else if (oRightIdx == rightIdx) {
        break // break case: newItem < other が確定
      } else {
        scanning = true // enter scanning case: 右側を確認するまで保留
      }
    } // stay same mode case: leftIdx < oLeftIdx のときは状態を維持

    if (!scanning)
      destIdx = i + 1
  }

  arr.insert(destIdx, newItem)
}
\end{lstlisting}

ループは素朴版と同様に左から右へ走査しますが、条件分岐と状態変数が増えています。ループ本体で \texttt{newItem} と \texttt{other} の順序を判断するには、前節の定義から以下の比較が必要です。\footnote{\origin{} と \texttt{newItem.origin} / \texttt{newItem.rightOrigin} の比較は、\texttt{newItem.origin < other < newItem.rightOrigin} が添字から分かるため不要です。}
\begin{itemize}
  \item \texttt{newItem} と \texttt{other.origin}、および \texttt{newItem} と \texttt{other.rightOrigin} の比較結果（定義の1, 2）
  \item \texttt{newItem.origin} と \texttt{other.origin}、および \texttt{newItem.id} と \texttt{other.id} の比較結果（定義の3-a, 3-b）
\end{itemize}

配列 \texttt{arr} が $<_Y$ でソート済みであることから、既存要素間の比較は添字を見れば分かります。しかし \texttt{newItem} と \texttt{other.rightOrigin} の比較は、\texttt{other.rightOrigin} が未訪問の位置にあるため直接は分かりません。YATAは以下の不変条件を維持しながら探索することで挿入位置を決定します。

ループの各反復で探索済み範囲 $[0, i)$ は\cref{fig:scan-range} のように2つに分割され、端点を \texttt{destIdx} が表します。

\begin{figure}[t]
  \centering
  \includegraphics[width=0.9\linewidth]{images/yjs-array.drawio.png}
  \caption{\texttt{integrate} の探索範囲}
  \label{fig:scan-range}
\end{figure}

任意の添字 $j$ について次が成り立ちます。
\begin{itemize}
  \item $j < \texttt{destIdx}$: \texttt{arr[j] < newItem}（確定して小さい範囲）。
  \item $\texttt{destIdx} \le j < i$: \texttt{newItem} との大小が未確定の範囲。後述するように、もし \texttt{newItem < other} ならこの範囲のすべての $j$ で \texttt{arr[j] < newItem} が成立します（図の青色部分）。
\end{itemize}

未確定範囲を導入する理由は、今見ている要素より後ろを参照しなくても順序を決めるためです。もしある時点で \texttt{newItem < other} と判明すれば、未確定範囲の全要素が \texttt{newItem} より大きいと分かり、挿入位置を決定できます。

不変条件を保ちつつアルゴリズムは以下のように動作します。
\begin{itemize}
  \item \textbf{Break case}: \texttt{newItem < other} が確定したらbreakし、未確定範囲全体が \texttt{newItem} より大きいので \texttt{destIdx} を挿入位置とする。
  \item \textbf{Enter scanning case}: 大小が確定できないときは \texttt{scanning = true} とし、未確定範囲を拡張する。
  \item \textbf{Leave scanning case}: \texttt{other < newItem} が確定すると推移律から未確定範囲も \texttt{newItem} より小さいため \texttt{scanning = false} として破棄する。
  \item \textbf{Stay same mode case}: フラグを変えず、未確定範囲があれば要素を追加し、なければ \texttt{other < newItem} を確定させる。
\end{itemize}

Lean-yjsでは次を示すことで \texttt{integrate} の正しさを証明しました。
\begin{itemize}
  \item 初期状態で不変条件が成り立つ。
  \item 各ケースで不変条件が保存される。
  \item break時および $i = \texttt{rightIdx}$ でループを抜ける際、\texttt{destIdx} が挿入位置であり、\texttt{arr[destIdx] < item < arr[destIdx + 1]} を満たす。
\end{itemize}

単純に見える可換性の証明でも、不変条件の管理は複雑で紙面だけで漏れなく行うのは困難であることが分かります。

\section{Specification}

CRDTアルゴリズムの性質としてstrong eventual consistency (SEC) があります。SECは「任意の2つのレプリカが同じ更新を異なる順序で適用しても同じ状態に収束する」ことを意味します。ただし適用順は因果順序 (causal order) を尊重する必要があります。因果順序とは、ある更新が別の更新を「知っている」ときに成立する関係で、Yjsでは \texttt{yText.insert(i, text)} から生成される更新が知っているのは、既に \texttt{yText} に挿入済みの要素です。因果順序に違反しないとは、更新 $a$ が更新 $b$ を知っているなら必ず $b$ を先に適用することを要求します。互いに因果関係にない2つの更新は並行 (concurrent) です。

op-based CRDTでは、effectフェイズの適用が可換であることがSECの十分条件として知られています。\footnote{CRDTにはop-basedとstate-basedの2種類があり、state-basedでは束を用いた十分条件がありますが本稿では扱いません。}ここで可換とは、更新 $u$ と状態 $s$ の関数 $f(u, s)$ について、任意の並行な更新 $u_1, u_2$ に対し $f(u_1, f(u_2, s)) = f(u_2, f(u_1, s))$ が成り立つことです。

可換性がSECを導く様子をYjsで考えます。同じ配列 \texttt{arr} を複製1, 2で保持し、それぞれが挿入 \texttt{x}, \texttt{y} を行うと、
\begin{itemize}
  \item レプリカ1は \texttt{integrate(arr, x)} の後に \texttt{y} を受信するので \texttt{integrate(integrate(arr, x), y)}。
  \item レプリカ2は \texttt{integrate(arr, y)} の後に \texttt{x} を受信するので \texttt{integrate(integrate(arr, y), x)}。
\end{itemize}
可換性より結果は一致します。一般の場合の定理を示します。

\paragraph{定理 (Strong eventual consistency).} Itemの集合 $S$ と関数 $f$ が可換、すなわち任意の $x, y \in S$ と配列 $l$ に対し $f(x, f(y, l)) = f(y, f(x, l))$ を満たすとします。このとき、$S$ の各要素をただ1つだけ含み、因果順序に違反しない2つのリスト $l_1, l_2$ に対して $\mathsf{foldl}(l_1, f, []) = \mathsf{foldl}(l_2, f, [])$ が成り立ちます。ここで、$l$ が因果順序に違反しないとは、任意の $a, b \in l$ について $a \prec b$ ならば $l$ 中で $a$ が $b$ より後に出現することを言います。

したがって \texttt{integrate} の正しさを示すには、その可換性を証明すれば十分です。

\section{Formalization}

この節ではLean4による形式化とその証明について述べます。Lean-yjsではYATA論文と同様に以下の流れで \texttt{integrate} アルゴリズムの可換性を証明しました。

1. Item間の順序 $<_Y$ が全順序であることを証明
2. integrateアルゴリズムが 1. の順序でソートされた配列を入力するとソートされた配列を計算することを証明
3. 2からCRDTが要求する可換性を満たすことを証明し、YATAが収束することを証明

以下では1--3の証明のスケッチを示します。実際の証明はLean-yjsの実装を参照してください。

\subsection{全順序性の証明}

全順序性の証明では$<_Y$がstrict total orderであること、つまり
\begin{itemize}
  \item 完全性: $\forall S: ItemSet.\, \forall  x, y \in S.\, x <_Y y \lor y \leq_Y x$
  \item 非対称性: $\forall S: ItemSet.\, \forall x, y \in S.\, x <_Y y \implies \neg y < x$
  \item 推移性:  $\forall S: ItemSet.\, \forall x, y, z \in S.\, x <_Y y \implies y <_Y z \implies x <_Y z$
\end{itemize}
を証明しました。これを示すことで$<_Y$によるソートは一意に定まるため、\texttt{integrate}が$<_Y$で整列した配列を返すことが分かれば挿入順序によらず結果が一意になります。各条件の仮定にある$S : ItemSet$はこれらの性質を成り立たせるための制約であり、次の節で解説します。

\subsubsection{ItemSet}

任意の \Item{} を許容すると、\texttt{insert} から生成されていないような \Item{} も比較対象になり、全順序性が壊れます。例えば \texttt{origin = Last}, \texttt{rightOrigin = First} とすると \texttt{Last < First} が導出でき非対称性と矛盾します。これを防ぐため、Lean-yjsでは良い性質を満たす有限集合に制限しました。これはYjsの挿入および \texttt{integrate} から生成されうる配列を集合として見たときの性質をモデル化したものです。

\begin{enumerate}[label=\arabic*.]
  \item $First, Last \in S$
  \item 任意の $i \in S$ について $i.\origin, i.\rightOrigin \in S$
  \item 任意の $i \in S$ について $i.\origin < i.\rightOrigin$
  \item 任意の $i \in S$ について、$i$ から \origin{}/\rightOrigin{} をたどって到達可能なすべての $x$ は $x \leq i.\origin$ または $i.\rightOrigin \leq x$ をみたす
  \item idの一意性: $\forall a b \in S, a.\textsf{id} \neq b.\textsf{id}$
\end{enumerate}

2は矛盾する参照を防ぎ、3は挿入時に既存要素と競合しないことを表します。4は \cref{fig:itemset-counter} のような反例を排除し、break caseの正当性を保証します。5は完全性の証明に必要で、同じIDがあると比較が決定できません。

\begin{figure}[t]
  \centering
  \includegraphics[width=0.85\linewidth]{images/yjs1-4.drawio.png}
  \caption{ItemSet条件を満たさない例}
  \label{fig:itemset-counter}
\end{figure}

この制約の下で完全性、非対称性、推移性はそれぞれ出現する \Item{} のサイズの和に関する帰納法で証明しました。\footnote{順序の定義選択によってどの性質の証明が難しくなるかが変わります。推移閉包をとれば推移律は楽になりますが反対称律のサイズ帰納法が難しくなり、逆も然りです。最終的には後者を採用しました。}

さらに以下の補題が成り立ちます。
$$
\forall x, y.\, x < y \implies y.\origin \leq x.\origin \lor x \leq y.\origin
$$
これは \origin{} への辺が交差しないことを意味し、no crossing補題と呼びます。YATA論文では定義の一部ですが、Lean-yjsでは補題として証明し、break caseの正当化に用いました。

\subsection{integrate アルゴリズムの可換性}

データ構造の不変条件として、配列はソート済みであり、ItemSetであり、かつ同じ要素が重複しないことを要求しました。Lean-yjsではこれを満たす \texttt{Array YjsItem} を \texttt{YjsArray} と定義し、次の定理を証明しました。

\begin{lstlisting}[language=Lean, caption={integrateが整列を保つ定理}, mathescape=true]
theorem YjsArrInvariant_integrate (newItem : YjsItem A)
    (arr newArr : Array (YjsItem A)) :
  YjsArrInvariant arr.toList
  → newItem.isValid
  → UniqueId newItem arr
  → integrate newItem arr = Except.ok newArr
  → ∃ i$\leq$arr.size,
      newArr = arr.insertIdxIfInBounds i newItem ∧
      YjsArrInvariant newArr.toList := by
\end{lstlisting}

\begin{lstlisting}[language=Lean, caption={integrateの可換性}]
theorem integrate_commutative (a b : YjsItem A)
    (arr1 arr2 arr3 arr2' arr3' : Array (YjsItem A)) :
  YjsArrInvariant arr1.toList
  → a.id ≠ b.id
  → InsertOk arr1 a
  → InsertOk arr1 b
  → integrate a arr1 = Except.ok arr2
  → integrate b arr2 = Except.ok arr3
  → integrate b arr1 = Except.ok arr2'
  → integrate a arr2' = Except.ok arr3'
  → arr3 = arr3' := by
\end{lstlisting}

後半の矢印列は、\texttt{arr1} に \texttt{a} を挿入してから \texttt{b} を挿入した場合と、その逆の場合で結果の配列が一致することを表します。

\texttt{InsertOk arr1 a} は \texttt{arr1} に \texttt{a} を挿入可能であるという仮定で、具体的には以下を含みます。
\begin{itemize}
  \item 未挿入である（\texttt{not\_mem}）。
  \item \texttt{origin}/\texttt{rightOrigin} がすでに配列に存在する（因果性）。
  \item \texttt{origin < rightOrigin} で循環しない。
  \item \origin{}/\rightOrigin{} から到達可能な要素や同じclientIdを持つ要素と競合しない。
\end{itemize}
これらの前提を満たさない \Item{} が \texttt{integrate} の入力になると収束性が失われます。YjsのAPIから生成された \Item{} は満たすはずですが、悪意あるクライアントからのパケットには耐性がありません（ビザンチン耐性の欠如）。

可換性の証明は以下の流れです。
\begin{enumerate}
  \item \texttt{integrate} はソート済み配列を保持する（入力がソート済みなら出力もソート済み）。
  \item 同じ集合の要素を含むソート済み配列は一意。
  \item よってソート済み \texttt{arr} に \texttt{a}, \texttt{b} を挿入した結果は集合として \texttt{arr ∪ a ∪ b} のソート済み配列となるため、挿入順序は可換。
\end{enumerate}

1の証明にはループ不変量を用いました。未確定範囲の要素は
\begin{itemize}
  \item \texttt{arr[j].origin} が未確定範囲にある、または
  \item \texttt{arr[j].origin = newItem.origin} かつ \texttt{newItem.id < arr[j].id}
\end{itemize}
のいずれかを満たします。この条件を満たす未確定範囲は、もし \texttt{newItem < arr[i]} が確定すると全要素について \texttt{newItem < arr[j]} が示せます。よって未確定範囲の最小添字 \texttt{destIdx} が挿入位置となり、\texttt{integrate} が正しい位置に挿入することが分かります。

\section{Differences from paper\cite{YATA16}}

YATA論文では$<_Y$の全順序性および \texttt{integrate} の正しさの証明が与えられていますが、形式検証の観点からは課題があります。

\subsection{全順序性のside condition}

Lean-yjsでは前述のとおり全順序性とアルゴリズムの正しさを示すために $S:\textsf{ItemSet}$ という制約を導入しました。YATA論文にはこの条件の言及がなく、この形式化はLean-yjsの成果です。

\subsection{順序関係の定義が定義できない}

YATA論文は競合する要素間の順序 $<_c$ を次のように定義します。
\begin{align*}
o_1 <_c o_2 \overset{\text{def}}{\iff} & o_1 < origin_2 \lor origin_2 \leq origin_1 \land \\
  & \nexists o.\, o_2 <_c o < c_1 \land \\
  & origin_1 = origin_2 \implies creator_1 < creator_2
\end{align*}
直感的には以下を意味します。
\begin{itemize}
  \item originエッジが交差しない
  \item 推移性\footnote{論文では推移性を意味するとありますが、むしろ非対称性に近いように見えます。}
  \item originが等しい場合はclientIdで比較
\end{itemize}
しかし(2)が否定の内側に再帰的に現れるためstrict positivityを満たさず、Lean4のような依存型理論の定理証明支援系では定義できません。矛盾が導けるかは未確認ですが、そのまま採用することはできませんでした。

\subsection{integrateアルゴリズムが収束しない}

以下はYATAの \texttt{integrate} を著者が配列ベースに書き換えたものですが、残念ながら収束しません。\footnote{YATAが間違っていることは著者も認めており、Seph Jentleが\url{https://news.ycombinator.com/item?id=41679056}で証言しています。Seph JentleはGoogle Waveの元開発者で、\url{https://josephg.com/blog/crdts-are-the-future/} の著者でもあり、その後Martin KleppmannとEg-walkerというOT/CRDTハイブリッドを提案しています（\url{https://arxiv.org/abs/2409.14252}）。}

\begin{lstlisting}[language=JavaScript, caption={YATA論文の配列表現 (収束しない例)}]
// TODO: YATA アルゴリズムの疑似コードをここに示す
\end{lstlisting}

まずクライアント1で \texttt{insert(0, "a")} を実行します。並行してクライアント2が \texttt{insert(0, "b")} を実行し、それを受信したクライアント3が \texttt{insert(1, "c")} を実行します（下図では \texttt{a(1)} はクライアント1による \texttt{"a"} の \Item{} を意味します）。

\begin{figure}[t]
  \centering
  \includegraphics[width=0.85\linewidth]{images/yjs1-3.drawio.png}
  \caption{YATA擬似コードが収束しない例}
  \label{fig:yata-diverge}
\end{figure}

aが挿入されているところにb, cを挿入すると、aとbではbの方がIDが大きいのでabになり、cはbをoriginとするのでabcとなります。

また、bcが挿入されているところにaを挿入すると、
\begin{itemize}
  \item \texttt{"b"} のIDは \texttt{"a"} より大きいので何も起きずに次へ進む。
  \item \texttt{"c"} のoriginは \texttt{"a"} のoriginより小さいので \texttt{position = 2} になり \texttt{bca} となり、\texttt{a → b → c} の順とは異なる結果に収束してしまう。
\end{itemize}

このような誤りがあるため、YjsではYATAに微妙な修正を加えたアルゴリズムを採用しています。特にscanning時の振る舞いが異なり、Yjsでは上記のバグは発生しません。

\section{Related Work}
Place the result among CRDT verification efforts and editor concurrency.

\section{Conclusion}

本稿ではYjsの競合解決アルゴリズムである`integrate`をLean4で形式的に証明するプロジェクトLean-yjsについて解説しました。証明した性質は収束性というCRDTの最も重要な性質です。また、Lean-yjsの開発の中で発見したYATA論文の問題点を示しました。具体的には順序関係の定義に形式化できないような形の再帰が含まれること、論文の擬似コードに問題があることと、収束性のための追加の条件が必要であることです。

実際のYjsの`integrate`アルゴリズムはLean-yjsのものよりもネストしたデータやRedo、連続したIDで隣り合うブロックのマージ等複雑です。Lean-yjsを拡張することでこれらの実装が正しいことを証明することを考えています。加えてより強い性質、例えばreplication-aware linealizabilityを示すことも考えられます。

\paragraph{Artifacts.} Repository: \url{https://github.com/iasakura/lean-yjs}.

\section{Acknowledgments}

本稿を書くにあたってYATA論文の不備を指摘をした際にその背景を親切に教えてくださったKevin Jahns氏に深く感謝申し上げます。

\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}

\end{document}
